// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSCalculateArray
#pragma kernel CSPostProcess
#pragma kernel CSMergeArrays
#pragma kernel CSGetPreviewTexture
#pragma kernel CSGetGlobalTexture
#pragma kernel CSGetMergedTexture

#include <HLSLSupport.cginc>
#include "ColorArrays.cginc"

// Input texture, okhsl array, and global okhsl array
Texture2D<fixed3> _InputTexture;
RWStructuredBuffer<int> _OKHSLArray;
RWStructuredBuffer<int> _GlobalOKHSLArray;

uint2 _OKHSLArrayResolution;

// Texture output stuff
RWTexture2D<float> _OutputArrayTexture;

// Return an array of all converted OKHSL colors
// Returns an array/"image" of which HSV colors are present within the input screenshot
// Essentially an "array" of applicable OKHSL colors
[numthreads(8,8,1)]
void CSCalculateArray (uint3 id : SV_DispatchThreadID)
{
    fixed3 color = _InputTexture[id.xy].rgb; 
    float3 okhsl = RGBtoOKHSL(color);
    
    uint2 arrayCoordinates = ArrayCoordinatesFromOKHSL(okhsl, _OKHSLArrayResolution);
    uint arrayIndex = ArrayIndexFromArrayCoordinates(arrayCoordinates, _OKHSLArrayResolution);
    InterlockedAdd(_OKHSLArray[arrayIndex], 1);

    // _OutputArrayTexture[arrayCoordinates] = 1; 
}

int GetIndexFromId(uint3 id)
{
    return id.x + (id.y * _OKHSLArrayResolution);
}

int MergeArrays(uint3 id)
{
    return _OKHSLArray[GetIndexFromId(id)] + _GlobalOKHSLArray[GetIndexFromId(id)];  
}

// Permanently merge the preview array into the global array
// _OKHSLArray, _GlobalOKHSLArray
[numthreads(8,8,1)]
void CSMergeArrays (uint3 id : SV_DispatchThreadID)
{
    _GlobalOKHSLArray[GetIndexFromId(id)] = MergeArrays(id);
}

// Get the preview texture (preview array only)
// _OutputArrayTexture, _OKHSLArray, _OKHSLArrayResolution
[numthreads(8,8,1)]
void CSGetPreviewTexture (uint3 id : SV_DispatchThreadID)
{
    _OutputArrayTexture[id.xy] = _OKHSLArray[GetIndexFromId(id)];
}

// Get the global texture (global array only)
// _OutputArrayTexture, _GlobalOKHSLArray, _OKHSLArrayResolution
[numthreads(8,8,1)]
void CSGetGlobalTexture (uint3 id : SV_DispatchThreadID)
{
    _OutputArrayTexture[id.xy] = _GlobalOKHSLArray[GetIndexFromId(id)];
}

// Get the merged texture (a combination of the preview array and global array)
// _OutputArrayTexture, _OKHSLArray, _GlobalOKHSLArray, _OKHSLArrayResolution
[numthreads(8,8,1)]
void CSGetMergedTexture (uint3 id : SV_DispatchThreadID)
{
    _OutputArrayTexture[id.xy] = MergeArrays(id);
}

// Contains all postprocessing data
// First, we have a _TopColorsCount amount of top colors in the format: (r, g, b, amount_seen), (h, s, l, arrayindex)
// Next, a color with the following data: (TotalUniqueColorsInPhoto, ColorCoveragePercentage, null, null)
RWStructuredBuffer<float4> _PostProcessArray;
uint _TopColorsCount;

// _OKHSLArray, _OKHSLArrayResolution
// TODO: Not be single threaded...
[numthreads(1,1,1)]
void CSPostProcess (uint3 id : SV_DispatchThreadID)
{
    int totalUniqueColors = 0;
    
    // use PostProcessArray as a temporary array
    for (int i = 0; i < (int)(_OKHSLArrayResolution.x * _OKHSLArrayResolution.y); i++)
    {
        float colorCount = _OKHSLArray[i];

        if (colorCount == 0)
            continue;

        totalUniqueColors++;
        for (int j = 0; j < (int)_TopColorsCount * 2; j+= 2)
        {
            if (_PostProcessArray[j].r > colorCount)
                continue;

            if (j + 2 < (int)_TopColorsCount)
            {
                _PostProcessArray[j + 2] = _PostProcessArray[j];
            }
            
            _PostProcessArray[j].r = colorCount;
            _PostProcessArray[j].g = i;
            break;
        }
    }

    // Convert our temporary array to proper colors
    for (int j = 0; j < (int)_TopColorsCount * 2; j += 2) 
    {
        float3 okhsl = OKHSLFromArrayIndex(_PostProcessArray[j].g, _OKHSLArrayResolution);
        float3 rgb = OKHSLtoRGB(okhsl);
        float amountSeen = _PostProcessArray[j].r;
        float index = _PostProcessArray[j].g;
        // 4th slot is used for frequency instead of alpha 
        _PostProcessArray[j] = float4(rgb.r, rgb.g, rgb.b, amountSeen);
        _PostProcessArray[j + 1] = float4(okhsl.r, okhsl.g, okhsl.b, index);
    }

    // Add our extra metadata
    _PostProcessArray[_TopColorsCount * 2] = float4(totalUniqueColors, ((float)totalUniqueColors / (_OKHSLArrayResolution.x * _OKHSLArrayResolution.y)) * 100, 0, 0);
}