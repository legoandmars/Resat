// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSCalculateArray
#pragma kernel CSPostProcess
#pragma kernel CSMergeArrays
#pragma kernel CSGetPreviewTexture
#pragma kernel CSGetGlobalTexture
#pragma kernel CSGetMergedTexture
#pragma kernel CSClearPreviewArray
#pragma kernel CSClearGlobalArray

#include <HLSLSupport.cginc>
#include "ColorArrays.cginc"

// Input texture, okhsl array, and global okhsl array
Texture2D<fixed3> _InputTexture;
RWStructuredBuffer<uint> _OKHSLArray;
RWStructuredBuffer<uint> _GlobalOKHSLArray;
RWStructuredBuffer<uint> _LargestElementIndexesArray;
RWStructuredBuffer<float4> _PostProcessArray;

uint _TopColorsCount;
uint2 _OKHSLArrayResolution;

// Texture output stuff
RWTexture2D<float> _OutputArrayTexture;

// Return an array of all converted OKHSL colors
// Returns an array/"image" of which HSV colors are present within the input screenshot
// Essentially an "array" of applicable OKHSL colors
[numthreads(8,8,1)]
void CSCalculateArray (uint3 id : SV_DispatchThreadID)
{
    fixed3 color = _InputTexture[id.xy].rgb; 
    float3 okhsl = RGBtoOKHSL(color);
    
    uint2 arrayCoordinates = ArrayCoordinatesFromOKHSL(okhsl, _OKHSLArrayResolution);
    uint arrayIndex = ArrayIndexFromArrayCoordinates(arrayCoordinates, _OKHSLArrayResolution);
    InterlockedAdd(_OKHSLArray[arrayIndex], 1);

    // _OutputArrayTexture[arrayCoordinates] = 1; 
}

int GetIndexFromId(uint3 id)
{
    return id.x + (id.y * _OKHSLArrayResolution);
}

int MergeArrays(uint3 id)
{
    return _OKHSLArray[GetIndexFromId(id)] + _GlobalOKHSLArray[GetIndexFromId(id)];  
}

// Permanently merge the preview array into the global array
// _OKHSLArray, _GlobalOKHSLArray
[numthreads(8,8,1)]
void CSMergeArrays (uint3 id : SV_DispatchThreadID)
{
    _GlobalOKHSLArray[GetIndexFromId(id)] = MergeArrays(id);
}

// Zero out global array
// _GlobalOKHSLArray
[numthreads(8,8,1)]
void CSClearGlobalArray (uint3 id : SV_DispatchThreadID)
{
    _GlobalOKHSLArray[GetIndexFromId(id)] = 0;
}

// Zero out preview array
// _OKHSLArray
[numthreads(8,8,1)]
void CSClearPreviewArray (uint3 id : SV_DispatchThreadID)
{
    _OKHSLArray[GetIndexFromId(id)] = 0;
}

// Get the preview texture (preview array only)
// _OutputArrayTexture, _OKHSLArray, _OKHSLArrayResolution
[numthreads(8,8,1)]
void CSGetPreviewTexture (uint3 id : SV_DispatchThreadID)
{
    _OutputArrayTexture[id.xy] = _OKHSLArray[GetIndexFromId(id)];
}

// Get the global texture (global array only)
// _OutputArrayTexture, _GlobalOKHSLArray, _OKHSLArrayResolution
[numthreads(8,8,1)]
void CSGetGlobalTexture (uint3 id : SV_DispatchThreadID)
{
    _OutputArrayTexture[id.xy] = _GlobalOKHSLArray[GetIndexFromId(id)];
}

// Get the merged texture (a combination of the preview array and global array)
// _OutputArrayTexture, _OKHSLArray, _GlobalOKHSLArray, _OKHSLArrayResolution
[numthreads(8,8,1)]
void CSGetMergedTexture (uint3 id : SV_DispatchThreadID)
{
    _OutputArrayTexture[id.xy] = MergeArrays(id);
}

// Contains all postprocessing data
// First, we have a _TopColorsCount amount of top colors in the format: (r, g, b, amount_seen), (h, s, l, arrayindex)
// Next, a color with the following data: (TotalUniqueColorsInPhoto, ColorCoveragePercentage, null, null)

// _OKHSLArray, _OKHSLArrayResolution
// TODO: Not be single threaded...
[numthreads(1,1,1)]
void CSPostProcess (uint3 id : SV_DispatchThreadID)
{
    int totalUniqueColors = 0;

    // final sort pass over our "top colors" array
    /*for (int i = 0; i < _OKHSLArrayResolution.y - 1; i++)
    {
        for (int j = i + 1; j > 0; j--)
        {
            if (_OKHSLArray[_LargestElementIndexesArray[j - 1]]  > _OKHSLArray[_LargestElementIndexesArray[j]])
            {
                int newItem = _LargestElementIndexesArray[j - 1];
                _LargestElementIndexesArray[j - 1] = _LargestElementIndexesArray[j];
                _LargestElementIndexesArray[j] = newItem;
            }
        }
    }*/

    // Convert our temporary array to proper colors
    for (int i = 0; i < (int)_TopColorsCount; i++)
    {
        float index = _LargestElementIndexesArray[i];
        float amountSeen = _OKHSLArray[index];
        float3 okhsl = OKHSLFromArrayIndex(index, _OKHSLArrayResolution);
        float3 rgb = OKHSLtoRGB(okhsl);

        _PostProcessArray[(i * 2)] = float4(rgb.r, rgb.g, rgb.b, amountSeen);
        _PostProcessArray[(i * 2) + 1] = float4(okhsl.r, okhsl.g, okhsl.b, index);
    }

    // Add our extra metadata
    _PostProcessArray[_TopColorsCount * 2] = float4(totalUniqueColors, ((float)totalUniqueColors / (_OKHSLArrayResolution.x * _OKHSLArrayResolution.y)) * 100, 0, 0);
}