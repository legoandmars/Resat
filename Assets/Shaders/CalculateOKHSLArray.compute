// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CSPostProcess

#include <HLSLSupport.cginc>
#include "ColorArrays.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<fixed3> _InputTexture;
RWStructuredBuffer<int> _OKHSLArray;

uint2 _OKHSLArrayResolution;
uint _PaletteSize;

// Texture output stuff
RWTexture2D<float> _OutputArrayTexture;

// Return an array of all converted OKHSL colors
// Returns an array/"image" of which HSV colors are present within the input screenshot
// Essentially an "array" of applicable OKHSL colors
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    fixed3 color = _InputTexture[id.xy].rgb;
    float3 okhsl = RGBtoOKHSL(color);
    
    uint2 arrayCoordinates = ArrayCoordinatesFromOKHSL(okhsl, _OKHSLArrayResolution);
    uint arrayIndex = ArrayIndexFromArrayCoordinates(arrayCoordinates, _OKHSLArrayResolution);
    InterlockedAdd(_OKHSLArray[arrayIndex], 1);

    _OutputArrayTexture[arrayCoordinates] = 1; 
}

// Contains all postprocessing data
// First, we have a _TopColorsCount amount of top colors in the format: (r, g, b, amount_seen), (h, s, l, arrayindex)
// Next, a color with the following data: (TotalUniqueColorsInPhoto, ColorCoveragePercentage, null, null)
RWStructuredBuffer<float4> _PostProcessArray;
uint _TopColorsCount;

// needs _OKHSLArray, _OKHSLArrayResolution
// TODO: Not be single threaded...
[numthreads(8,8,1)]
void CSPostProcess (uint3 id : SV_DispatchThreadID)
{
    int totalUniqueColors = 0;
    
    // use PostProcessArray as a temporary array
    for (int i = 0; i < (int)(_OKHSLArrayResolution.x * _OKHSLArrayResolution.y); i++)
    {
        float colorCount = _OKHSLArray[i];

        if (colorCount == 0)
            continue;

        totalUniqueColors++;
        for (int j = 0; j < (int)_TopColorsCount * 2; j+= 2)
        {
            if (_PostProcessArray[j].r > colorCount)
                continue;

            if (j + 2 < (int)_TopColorsCount)
            {
                _PostProcessArray[j + 2] = _PostProcessArray[j];
            }
            
            _PostProcessArray[j].r = colorCount;
            _PostProcessArray[j].g = i;
            break;
        }
    }

    // Convert our temporary array to proper colors
    for (int j = 0; j < (int)_TopColorsCount * 2; j += 2) 
    {
        float3 okhsl = OKHSLFromArrayIndex(_PostProcessArray[j].g, _OKHSLArrayResolution);
        float3 rgb = OKHSLtoRGB(okhsl);
        float amountSeen = _PostProcessArray[j].r;
        float index = _PostProcessArray[j].g;
        // 4th slot is used for frequency instead of alpha 
        _PostProcessArray[j] = float4(rgb.r, rgb.g, rgb.b, amountSeen);
        _PostProcessArray[j + 1] = float4(okhsl.r, okhsl.g, okhsl.b, index);
    }

    // Add our extra metadata
    _PostProcessArray[_TopColorsCount * 2] = float4(totalUniqueColors, ((float)totalUniqueColors / (_OKHSLArrayResolution.x * _OKHSLArrayResolution.y)) * 100, 0, 0);
}