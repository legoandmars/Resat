#pragma kernel CSGetLargestElementsInArray

#include <HLSLSupport.cginc>
#include "ColorArrays.cginc"

StructuredBuffer<int> _OKHSLArray;
StructuredBuffer<int> _GlobalOKHSLArray;
// RWStructuredBuffer<int> _LargestElementIndexesArray;
RWStructuredBuffer<float4> _TopColorArray;
RWStructuredBuffer<int> _OtherMetadataArray; // bit annoying needing a second GetData call but whatever man, no InterlockedAdd for floats

uint2 _OKHSLArrayResolution;

// Contains all postprocessing data
// First, we have a _TopColorsCount amount of top colors in the format: (r, g, b, amount_seen), (h, s, l, arrayindex)
// Next, a color with the following data: (TotalUniqueColorsInPhoto, ColorCoveragePercentage, null, null)

// uses a scuffed sort
// first thread is set to image Y length
// returns unsorted (y_length) elements, guaranteed to be the largest (y_length) elements in the list
[numthreads(8,1,1)]
void CSGetLargestElementsInArray (uint3 id : SV_DispatchThreadID)
{
    // TODO: way to not return existing global colors as top colors?
    uint newColorCount = 0;
    uint colorCount = 0;
    
    int startIndex = id.x * _OKHSLArrayResolution.x;

    uint maxValue = 0;
    uint maxIndex = 0;
    
    for (int i = 0; i < _OKHSLArrayResolution.x; i++)
    {
        int index = startIndex + i;
        int value = _OKHSLArray[index];
        
        if (value > maxValue)
        {
            maxValue = value;
            maxIndex = index;
        }

        if (value != 0)
        {
            colorCount += 1;
            
            // TODO: Do the below bit as a merge before to save perf
            if (_GlobalOKHSLArray[index] == 0)
            {
                newColorCount += 1;
            }
        }
    }

    float3 okhsl = OKHSLFromArrayIndex(maxIndex, _OKHSLArrayResolution);
    float3 rgb = OKHSLtoRGB(okhsl);
    
    _TopColorArray[(id.x * 2)] = float4(rgb.r, rgb.g, rgb.b, maxValue);
    _TopColorArray[(id.x * 2) + 1] = float4(okhsl.r, okhsl.g, okhsl.b, maxIndex);

    // Add our extra metadata
    InterlockedAdd(_OtherMetadataArray[0], colorCount);
    InterlockedAdd(_OtherMetadataArray[1], newColorCount);

    // InterlockedAdd(existingColors, 1);
}
